/*! dragon-smaug v1.0.0 | MIT */
(function (root, factory) {
  if (typeof define === "function" && define.amd) {
    define([], factory);
  } else if (typeof module === "object" && module.exports) {
    module.exports = factory();
  } else {
    root.DragonSmaug = factory();
  }
})(typeof self !== "undefined" ? self : this, function () {
  "use strict";

  function createCanvas(target, width, height) {
    let el =
      typeof target === "string" ? document.querySelector(target) : target;
    if (!el) throw new Error("DragonSmaug: élément cible introuvable");
    let canvas;
    if (el instanceof HTMLCanvasElement) {
      canvas = el;
      canvas.width = width;
      canvas.height = height;
    } else {
      canvas = document.createElement("canvas");
      canvas.width = width;
      canvas.height = height;
      canvas.style.display = "block";
      canvas.style.margin = "20px auto";
      canvas.style.background = "#111";
      canvas.style.border = "1px solid #333";
      el.appendChild(canvas);
    }
    return canvas;
  }

  function randInt(max) {
    return Math.floor(Math.random() * max);
  }

  function posEq(a, b) {
    return a.x === b.x && a.y === b.y;
  }

  function createSnakeGame(options) {
    const opts = Object.assign(
      {
        target: "#game",
        cols: 20,
        rows: 20,
        // if null, cell will be computed automatically to fit the container
        cell: null,
        speedMs: 120,
        wallIsDeath: true,
        bg: "#0f0f0f",
        snakeColor: "#6ee7b7",
        headColor: "#34d399",
        foodColor: "#f59e0b",
        onScore: null,
        onGameOver: null,
      },
      options || {}
    );

    // If cell wasn't provided, compute a sensible value based on the target container
    let targetEl =
      typeof opts.target === "string"
        ? document.querySelector(opts.target)
        : opts.target;
    if (!targetEl) throw new Error("DragonSmaug: target element not found");

    if (opts.cell == null) {
      // try to read container size
      const rect = targetEl.getBoundingClientRect
        ? targetEl.getBoundingClientRect()
        : null;
      const containerWidth =
        rect && rect.width > 0
          ? rect.width
          : Math.max(1, targetEl.clientWidth || window.innerWidth);
      const containerHeight =
        rect && rect.height > 0
          ? rect.height
          : Math.max(0, targetEl.clientHeight || window.innerHeight);

      const cellByWidth = Math.floor(containerWidth / Math.max(1, opts.cols));
      const cellByHeight =
        containerHeight > 0
          ? Math.floor(containerHeight / Math.max(1, opts.rows))
          : cellByWidth;
      // choose the smaller to fit both dimensions, and clamp to reasonable range
      let autoCell = Math.max(6, Math.min(cellByWidth, cellByHeight));
      if (autoCell < 6) autoCell = 6;
      if (autoCell > 128) autoCell = 128;
      opts.cell = autoCell;
    }

    const width = opts.cols * opts.cell;
    const height = opts.rows * opts.cell;
    const canvas = createCanvas(targetEl, width, height);
    const ctx = canvas.getContext("2d");

    // Make the canvas responsive to its container and crisp on high-DPI screens.
    let resizeObserver = null;
    let fallbackResize = null;
    // current logical -> backing scale factors (set by resize)
    let currentScale = { sx: 1, sy: 1 };
    (function setupResponsiveCanvas() {
      const logicalW = opts.cols * opts.cell;
      const logicalH = opts.rows * opts.cell;

      function resize() {
        const parent = canvas.parentNode || document.body;
        const rect = parent.getBoundingClientRect
          ? parent.getBoundingClientRect()
          : null;
        const containerWidth =
          rect && rect.width > 0 ? rect.width : Math.max(1, parent.clientWidth);
        const containerHeight =
          rect && rect.height > 0
            ? rect.height
            : Math.max(0, parent.clientHeight);
        // scale factors
        const scaleW = containerWidth / logicalW;
        const scaleH = containerHeight > 0 ? containerHeight / logicalH : null;
        // if container height is not available (auto), fall back to width-only scaling
        const scaleCSS = scaleH === null ? scaleW : Math.min(scaleW, scaleH);

        const dpr = window.devicePixelRatio || 1;

        // backing/store size in physical pixels
        const backingWidth = Math.max(1, Math.floor(logicalW * scaleCSS * dpr));
        const backingHeight = Math.max(
          1,
          Math.floor(logicalH * scaleCSS * dpr)
        );

        canvas.width = backingWidth;
        canvas.height = backingHeight;

        // style size in CSS pixels
        canvas.style.width = Math.floor(logicalW * scaleCSS) + "px";
        canvas.style.height = Math.floor(logicalH * scaleCSS) + "px";

        // map logical units (px in original code) to backing pixels
        const sx = backingWidth / logicalW;
        const sy = backingHeight / logicalH;
        currentScale.sx = sx;
        currentScale.sy = sy;
        ctx.setTransform(sx, 0, 0, sy, 0, 0);
      }

      // initial resize
      resize();

      // observe parent size changes if supported
      try {
        if (window.ResizeObserver) {
          resizeObserver = new ResizeObserver(resize);
          const parent = canvas.parentNode || document.body;
          resizeObserver.observe(parent);
        } else {
          // fallback: listen to window resize
          fallbackResize = resize;
          window.addEventListener("resize", fallbackResize);
        }
      } catch (e) {
        // if anything fails, ignore and keep initial sizing
      }
    })();

    let snake, dir, pendingDir, food, timer, running, score;

    function reset() {
      snake = [{ x: Math.floor(opts.cols / 2), y: Math.floor(opts.rows / 2) }];
      dir = { x: 1, y: 0 };
      pendingDir = null;
      score = 0;
      placeFood();
      draw();
    }

    function placeFood() {
      while (true) {
        const f = { x: randInt(opts.cols), y: randInt(opts.rows) };
        if (!snake.some((s) => posEq(s, f))) {
          food = f;
          return;
        }
      }
    }

    function setDirection(nx, ny) {
      // Prevent direct reverse movement
      if (nx === -dir.x && ny === -dir.y) return;
      pendingDir = { x: nx, y: ny };
    }

    function keyHandler(e) {
      switch (e.key) {
        case "ArrowUp":
        case "w":
        case "W":
          setDirection(0, -1);
          break;
        case "ArrowDown":
        case "s":
        case "S":
          setDirection(0, 1);
          break;
        case "ArrowLeft":
        case "a":
        case "A":
          setDirection(-1, 0);
          break;
        case "ArrowRight":
        case "d":
        case "D":
          setDirection(1, 0);
          break;
      }
    }

    function step() {
      if (pendingDir) {
        dir = pendingDir;
        pendingDir = null;
      }

      const head = snake[0];
      let nx = head.x + dir.x;
      let ny = head.y + dir.y;

      if (opts.wallIsDeath) {
        if (nx < 0 || ny < 0 || nx >= opts.cols || ny >= opts.rows) {
          return gameOver();
        }
      } else {
        // wrap-around
        nx = (nx + opts.cols) % opts.cols;
        ny = (ny + opts.rows) % opts.rows;
      }

      const newHead = { x: nx, y: ny };

      // self-collision
      if (snake.some((s) => posEq(s, newHead))) {
        return gameOver();
      }

      snake.unshift(newHead);

      if (posEq(newHead, food)) {
        score++;
        if (typeof opts.onScore === "function") opts.onScore(score);
        placeFood();
      } else {
        snake.pop();
      }

      draw();
    }

    function draw() {
      // Clear backing pixels using identity transform to avoid artifacts/trails
      ctx.save();
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.fillStyle = opts.bg;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.restore();

      // now draw using logical coordinate transform (already set)

      // food
      ctx.fillStyle = opts.foodColor;
      ctx.fillRect(
        food.x * opts.cell,
        food.y * opts.cell,
        opts.cell,
        opts.cell
      );

      // snake
      snake.forEach((seg, i) => {
        ctx.fillStyle = i === 0 ? opts.headColor : opts.snakeColor;
        ctx.fillRect(
          seg.x * opts.cell,
          seg.y * opts.cell,
          opts.cell,
          opts.cell
        );
      });

      // score (HUD)
      // score (HUD) — draw in backing pixels so it remains readable regardless of logical grid size
      ctx.save();
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      // choose HUD font based on visible canvas size (backing pixels), not logical grid
      const shortSideHUD = Math.min(canvas.width, canvas.height);
      let hudFont = Math.round(shortSideHUD * 0.035);
      // clamp HUD font between 12px and 48px
      if (hudFont < 12) hudFont = 12;
      if (hudFont > 48) hudFont = 48;
      ctx.fillStyle = "#e5e7eb";
      ctx.font = hudFont + "px sans-serif";
      // small padding from top-left in backing pixels
      ctx.fillText("Score: " + score, 8, hudFont + 4);
      ctx.restore();
    }

    // Start the game loop immediately (without countdown)
    function startNow() {
      if (timer) clearInterval(timer);
      timer = setInterval(step, opts.speedMs);
      running = true;
      window.addEventListener("keydown", keyHandler);
    }

    // Display a visual countdown (3,2,1,GO) then call `done()`
    function showCountdown(done) {
      // Stop the game and disable handlers during the countdown
      pause();
      const frames = ["3", "2", "1", "GO"];
      const delays = [700, 700, 700, 500];
      let i = 0;

      function renderFrame(text) {
        // Clear backing pixels first (identity transform) to avoid stacking/trails
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.fillStyle = opts.bg || "#000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "rgba(0,0,0,0.6)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.restore();
        // draw centered text in backing pixels coordinates with dynamic size
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.fillStyle = "#fff";
        // choose font size relative to shortest canvas side
        const shortSide = Math.min(canvas.width, canvas.height);
        let overlayFont = Math.round(shortSide * 0.18);
        // clamp overlay font between 24px and 200px
        if (overlayFont < 24) overlayFont = 24;
        if (overlayFont > 200) overlayFont = 200;
        ctx.font = "bold " + overlayFont + "px system-ui, sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(text, canvas.width / 2, canvas.height / 2);
        ctx.restore();
      }

      function next() {
        renderFrame(frames[i]);
        const delay = delays[i] || 500;
        i++;
        if (i < frames.length) {
          setTimeout(next, delay);
        } else {
          // After the last frame, redraw and trigger the continuation
          setTimeout(function () {
            draw();
            if (typeof done === "function") done();
          }, delay);
        }
      }

      next();
    }

    function pause() {
      if (timer) clearInterval(timer);
      timer = null;
      running = false;
      window.removeEventListener("keydown", keyHandler);
    }

    // NOTE: toggle/pause functionality removed — game cannot be paused by user

    function gameOver() {
      pause();
      if (typeof opts.onGameOver === "function") opts.onGameOver(score);

      // overlay: clear then draw overlay in backing-pixel coordinates to avoid trails
      ctx.save();
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.fillStyle = "rgba(0,0,0,0.6)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "#fff";
      const shortSide = Math.min(canvas.width, canvas.height);
      let titleFont = Math.round(shortSide * 0.06);
      let subFont = Math.round(shortSide * 0.035);
      // clamp sizes
      if (titleFont < 20) titleFont = 20;
      if (titleFont > 120) titleFont = 120;
      if (subFont < 12) subFont = 12;
      if (subFont > 60) subFont = 60;
      ctx.font = "bold " + titleFont + "px system-ui, sans-serif";
      ctx.textAlign = "center";
      ctx.fillText(
        "Game Over",
        canvas.width / 2,
        canvas.height / 2 - Math.round(shortSide * 0.06)
      );
      ctx.font = subFont + "px system-ui, sans-serif";
      ctx.fillText(
        "Score: " + score + "  —  Press R to restart",
        canvas.width / 2,
        canvas.height / 2 + Math.round(shortSide * 0.04)
      );
      ctx.restore();

      function rKey(e) {
        if (e.key === "r" || e.key === "R") {
          window.removeEventListener("keydown", rKey);
          reset();
          // show countdown before restarting
          showCountdown(startNow);
        }
      }
      window.addEventListener("keydown", rKey);
    }

    reset();
    // On load, run the countdown before starting the game
    showCountdown(startNow);

    return {
      canvas,
      // start() triggers the countdown then starts the game
      start() {
        showCountdown(startNow);
      },
      // destroy() stops the loop if needed and removes the canvas
      destroy() {
        // use internal pause to ensure the interval is cleared
        pause();
        try {
          if (
            resizeObserver &&
            typeof resizeObserver.disconnect === "function"
          ) {
            resizeObserver.disconnect();
          } else if (fallbackResize) {
            window.removeEventListener("resize", fallbackResize);
          }
        } catch (e) {
          // ignore
        }
        const parent = canvas.parentNode;
        if (parent) parent.removeChild(canvas);
      },
    };
  }

  // API (UMD)
  return {
    /**
     * @param {HTMLElement|string} target
     * @param {object} options
     * @returns controller { start(), destroy(), canvas }
     */
    mount(target, options) {
      return createSnakeGame(Object.assign({ target }, options));
    },
  };
});
const game = DragonSmaug.mount('#game', {
  cols: 16,
  rows: 8,
  speedMs: 140,
  onGameOver(score) { console.log("Score final:", score); }
});
game.start();
